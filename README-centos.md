# README for akceph-build CentOS support

<!-- vscode-markdown-toc -->

<!-- vscode-markdown-toc-config
	numbering=false
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->

## Prerequisites

These steps need to be run on a host system that has the Red Hat packaging
tools, specifically `rpm` and `createrepo_c`. These tools aren't generally
installed on Ubuntu hosts.

This could also be run containerised if 'container-in-container' mode is
supported on the host, but this seems complex given how easily we can create
CentOS VMs.

## Example use

```sh
# You'll need 'real' Docker, or Podman in daemon mode. Otherwise the
# filesystem mounts won't work.

# Copy configuration variables. You should check these!
cp vars.sh.example vars.sh

# Build RPMS (binary packages) and SRPMS (source packages) for the given
# branch. This will take some time!
./rpm-build.sh -s v18.2.1

# Take the output from the above and package it into standard-ish Ceph
# containers using a modified ceph-container repository.
# The images created will be listed at the end of the run.
./official-container.sh -r rpmbuild_v18.2.1

# The same, but automatically push the containers to the upstream repository.
./official-container.sh -r rpmbuild_v18.2.1 -u

# Build branch RPMs, build containers, and push, all-in-one.
./official-container.sh -s v18.2.1 -u
```

## Build process

### `rpm-build.sh`

This is a fairly straightforward process, all the work to build the packages
is in the Ceph source tree.

- Generate a build image in which the build can take place. This will check
  out the source tree directly into the build image - we're not looking to use
  this for development here - but will stop short of actually running the
  build. Notice that the container has our custom build dependencies just the
  same as the Ubuntu container, and in fact uses the same build scripts.

- In a container running from the build image, run `build.sh`, which runs the
  two-step process required to build Ceph RPMs:

    - First, generate the source RPM file using `make-srpm.sh` in the Ceph
      source.

    - Then, build the binary RPMs using the source RPM.

The binary and source RPMs are stored in `rpmbuild_<BRANCH>` on the host,
where `BRANCH` is sanitised to be a valid path.

### `official-container.sh`

The next step is to take the RPMs and SRPMs generated by `rpm-build.sh` and
turn them into upstream containers, and from there into a special
gen2-specific container.

- Extract some metadata from the packages in `rpmbuild_<BRANCH>`. We'll need
  this to know what to call things. If `-s` is used, the script will build the
  packages for the rpmbuild directory first.

- Copy the RPMs and SRPMs to a temporary directory.

- Run `createrepo_c` (a Red Hat tool to generate Yum repositories from a file
  tree) on `RPMS/noarch`, `RPMS/x86_64` and `SRPMS` in the temporary
  directory.
  
- Run an nginx web server on a random port to advertise the newly-created Yum
  repositories. Test the web server works before proceeding.

- Run `make` on our modified ceph-container repo (which is in a submodule of
  this repository) with a number of carefully-customised options. This
  generates the `daemon-base`, `daemon` and `demo` standard Ceph Docker
  images, using our RPM packages.

- Use the generated `daemon` image as the source to generate our gen2-specific
  Docker image, which simply runs as a non-root user and changes some
  permissions.

- If specified, push the images to a remote repository.

The use of a web server to publish the RPMs is somewhat frustrating, but
it's how the existing tool works, and changing it would be a significant
nuisance. It's easy enough to start an nginx container.
